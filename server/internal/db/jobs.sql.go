// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package db

import (
	"context"
	"encoding/json"
	"time"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs(
job_type,
description,
job_date,
season_id,
area_in_meters,
created_at,
updated_at
)
VALUES(
  $1,
  $2,
  $3,
  $4,
  $5,
  CURRENT_TIMESTAMP,
  CURRENT_TIMESTAMP
  ) returning id, job_type, description, job_date, area_in_meters, boundary, season_id, created_at, updated_at, deleted_at
`

type CreateJobParams struct {
	JobType      string
	Description  *string
	JobDate      time.Time
	SeasonID     int64
	AreaInMeters float64
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.JobType,
		arg.Description,
		arg.JobDate,
		arg.SeasonID,
		arg.AreaInMeters,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Description,
		&i.JobDate,
		&i.AreaInMeters,
		&i.Boundary,
		&i.SeasonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createJobSupplies = `-- name: CreateJobSupplies :one
INSERT INTO jobs_supplies (
quantity,
job_id,
supply_id,
created_at,
updated_at
)
VALUES(
  $1,
  $2,
  $3,
  CURRENT_TIMESTAMP,
  CURRENT_TIMESTAMP
  ) RETURNING id, quantity, job_id, supply_id, created_at, updated_at, deleted_at
`

type CreateJobSuppliesParams struct {
	Quantity float64
	JobID    *int64
	SupplyID *int64
}

func (q *Queries) CreateJobSupplies(ctx context.Context, arg CreateJobSuppliesParams) (JobsSupply, error) {
	row := q.db.QueryRow(ctx, createJobSupplies, arg.Quantity, arg.JobID, arg.SupplyID)
	var i JobsSupply
	err := row.Scan(
		&i.ID,
		&i.Quantity,
		&i.JobID,
		&i.SupplyID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs
WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const getAllJobs = `-- name: GetAllJobs :many

select j.id,j.job_type,j.description,j.job_date,j.season_id,j.area_in_meters,j.boundary,j.created_at,j.updated_at,
  COALESCE(
    json_agg(
      json_build_object(
        'id',js.id,
        'quantity',js.quantity,
        'jobId',js.job_id,
        'createdAt',js.created_at,
        'updatedAt',js.updated_at,
        'supplyName',s.name,
        'supplyAlias',s.nickname,
        'supplyId',js.supply_id,
        'supplyMeasurementUnit',s.measurement_unit
       )
  ) FILTER (WHERE js.id IS NOT NULL),
    '[]'::json
  ) AS jobs_supplies
FROM jobs AS j
LEFT JOIN jobs_supplies AS js
ON j.id = js.job_id
LEFT JOIN supplies AS s
ON js.supply_id = s.id
WHERE j.deleted_at IS NULL AND js.deleted_at IS NULL AND s.deleted_at IS NULL AND  j.season_id=$1
GROUP BY j.id
ORDER BY job_date DESC
`

type GetAllJobsRow struct {
	ID           int64
	JobType      string
	Description  *string
	JobDate      time.Time
	SeasonID     int64
	AreaInMeters float64
	Boundary     *json.RawMessage
	CreatedAt    *time.Time
	UpdatedAt    *time.Time
	JobsSupplies *json.RawMessage
}

func (q *Queries) GetAllJobs(ctx context.Context, seasonID int64) ([]GetAllJobsRow, error) {
	rows, err := q.db.Query(ctx, getAllJobs, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsRow
	for rows.Next() {
		var i GetAllJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Description,
			&i.JobDate,
			&i.SeasonID,
			&i.AreaInMeters,
			&i.Boundary,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JobsSupplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstJobBySeasonId = `-- name: GetFirstJobBySeasonId :one
select id, job_type, description, job_date, area_in_meters, boundary, season_id, created_at, updated_at, deleted_at
FROM jobs j 
WHERE j.deleted_at IS NULL  AND j.season_id=$1
ORDER BY job_date ASC
LIMIT 1
`

func (q *Queries) GetFirstJobBySeasonId(ctx context.Context, seasonID int64) (Job, error) {
	row := q.db.QueryRow(ctx, getFirstJobBySeasonId, seasonID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Description,
		&i.JobDate,
		&i.AreaInMeters,
		&i.Boundary,
		&i.SeasonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getJobDetails = `-- name: GetJobDetails :one
select j.id,j.job_type,j.description,j.job_date,j.season_id,j.area_in_meters,j.boundary,j.created_at,j.updated_at,
  COALESCE(
    json_agg(
      json_build_object(
        'id',js.id,
        'quantity',js.quantity,
        'jobId',js.job_id,
        'createdAt',js.created_at,
        'updatedAt',js.updated_at,
        'supplyName',s.name,
        'supplyAlias',s.nickname,
        'supplyId',js.supply_id,
        'supplyMeasurementUnit',s.measurement_unit
       )
  ) FILTER (WHERE js.id IS NOT NULL),
    '[]'::json
  ) AS jobs_supplies
FROM jobs AS j
LEFT JOIN jobs_supplies AS js
ON j.id = js.job_id
LEFT JOIN supplies AS s
ON js.supply_id = s.id
WHERE j.deleted_at IS NULL AND js.deleted_at IS NULL AND s.deleted_at IS NULL AND job_id=$1 AND  j.season_id=$2
GROUP BY j.id
`

type GetJobDetailsParams struct {
	JobID    *int64
	SeasonID int64
}

type GetJobDetailsRow struct {
	ID           int64
	JobType      string
	Description  *string
	JobDate      time.Time
	SeasonID     int64
	AreaInMeters float64
	Boundary     *json.RawMessage
	CreatedAt    *time.Time
	UpdatedAt    *time.Time
	JobsSupplies *json.RawMessage
}

func (q *Queries) GetJobDetails(ctx context.Context, arg GetJobDetailsParams) (GetJobDetailsRow, error) {
	row := q.db.QueryRow(ctx, getJobDetails, arg.JobID, arg.SeasonID)
	var i GetJobDetailsRow
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Description,
		&i.JobDate,
		&i.SeasonID,
		&i.AreaInMeters,
		&i.Boundary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JobsSupplies,
	)
	return i, err
}

const getLastJobBySeasonId = `-- name: GetLastJobBySeasonId :one
select id, job_type, description, job_date, area_in_meters, boundary, season_id, created_at, updated_at, deleted_at
FROM jobs j 
WHERE j.deleted_at IS NULL  AND j.season_id=$1
ORDER BY job_date DESC
LIMIT 1
`

func (q *Queries) GetLastJobBySeasonId(ctx context.Context, seasonID int64) (Job, error) {
	row := q.db.QueryRow(ctx, getLastJobBySeasonId, seasonID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Description,
		&i.JobDate,
		&i.AreaInMeters,
		&i.Boundary,
		&i.SeasonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const jobExists = `-- name: JobExists :one
SELECT farms.id FROM jobs
JOIN seasons
ON season_id = seasons.id
AND jobs.id = $1
JOIN fields
ON fields.id = seasons.field_id
JOIN farms
ON farms.id = $2
`

type JobExistsParams struct {
	JobID  int64
	FarmID int64
}

func (q *Queries) JobExists(ctx context.Context, arg JobExistsParams) (int64, error) {
	row := q.db.QueryRow(ctx, jobExists, arg.JobID, arg.FarmID)
	var id int64
	err := row.Scan(&id)
	return id, err
}
