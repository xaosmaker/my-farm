// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs(
job_type,
description,
job_date,
field_id,
created_at,
updated_at
)
VALUES(
  $1,
  $2,
  $3,
  $4,
  CURRENT_TIMESTAMP,
  CURRENT_TIMESTAMP
  ) returning id, job_type, description, job_date, field_id, created_at, updated_at, deleted_at
`

type CreateJobParams struct {
	JobType     string
	Description *string
	JobDate     pgtype.Timestamptz
	FieldID     int64
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.JobType,
		arg.Description,
		arg.JobDate,
		arg.FieldID,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Description,
		&i.JobDate,
		&i.FieldID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createJobSupplies = `-- name: CreateJobSupplies :one
INSERT INTO jobs_supplies (
quantity,
job_id,
supply_id,
created_at,
updated_at
)
VALUES(
  $1,
  $2,
  $3,
  CURRENT_TIMESTAMP,
  CURRENT_TIMESTAMP
  ) RETURNING id, quantity, job_id, supply_id, created_at, updated_at, deleted_at
`

type CreateJobSuppliesParams struct {
	Quantity float64
	JobID    *int64
	SupplyID *int64
}

func (q *Queries) CreateJobSupplies(ctx context.Context, arg CreateJobSuppliesParams) (JobsSupply, error) {
	row := q.db.QueryRow(ctx, createJobSupplies, arg.Quantity, arg.JobID, arg.SupplyID)
	var i JobsSupply
	err := row.Scan(
		&i.ID,
		&i.Quantity,
		&i.JobID,
		&i.SupplyID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllJobs = `-- name: GetAllJobs :many

select j.id,j.job_type,j.description,j.job_date,
j.field_id,j.created_at,j.updated_at, 
COUNT(j) AS total_supplies
FROM jobs AS j
LEFT JOIN jobs_supplies AS js
ON j.id = js.job_id
WHERE j.deleted_at IS NULL AND js.deleted_at IS NULL  AND  j.field_id=$1

GROUP BY j.id
`

type GetAllJobsRow struct {
	ID            int64
	JobType       string
	Description   *string
	JobDate       pgtype.Timestamptz
	FieldID       int64
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	TotalSupplies int64
}

func (q *Queries) GetAllJobs(ctx context.Context, fieldID int64) ([]GetAllJobsRow, error) {
	rows, err := q.db.Query(ctx, getAllJobs, fieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsRow
	for rows.Next() {
		var i GetAllJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Description,
			&i.JobDate,
			&i.FieldID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalSupplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobDetails = `-- name: GetJobDetails :one
select j.id,j.job_type,j.description,j.job_date,j.field_id,j.created_at,j.updated_at,
  COALESCE(
    json_agg(
      json_build_object(
        'id',js.id,
        'quantity',js.quantity,
        'jobId',js.job_id,
        'supplyId',js.supply_id,
        'createdAt',js.created_at,
        'updatedAt',js.updated_at
       )
  ) FILTER (WHERE js.id IS NOT NULL),
    '[]'::json
  ) AS jobs_supplies
FROM jobs AS j
LEFT JOIN jobs_supplies AS js
ON j.id = js.job_id
WHERE j.deleted_at IS NULL AND js.deleted_at IS NULL AND job_id=$1 AND  j.field_id=$2
GROUP BY j.id
`

type GetJobDetailsParams struct {
	JobID   *int64
	FieldID int64
}

type GetJobDetailsRow struct {
	ID           int64
	JobType      string
	Description  *string
	JobDate      pgtype.Timestamptz
	FieldID      int64
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	JobsSupplies *json.RawMessage
}

func (q *Queries) GetJobDetails(ctx context.Context, arg GetJobDetailsParams) (GetJobDetailsRow, error) {
	row := q.db.QueryRow(ctx, getJobDetails, arg.JobID, arg.FieldID)
	var i GetJobDetailsRow
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Description,
		&i.JobDate,
		&i.FieldID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JobsSupplies,
	)
	return i, err
}
