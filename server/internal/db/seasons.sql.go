// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: seasons.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSeason = `-- name: CreateSeason :one
INSERT INTO seasons
(name,field_id,crop,area_in_meters,start_season)
VALUES ($1,$2,$3,$4,$5)returning id, field_id, name, start_season, finish_season, crop, boundary, area_in_meters, created_at, updated_at, deleted_at
`

type CreateSeasonParams struct {
	Name         *string
	FieldID      int64
	Crop         int64
	AreaInMeters float64
	StartSeason  time.Time
}

func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) (Season, error) {
	row := q.db.QueryRow(ctx, createSeason,
		arg.Name,
		arg.FieldID,
		arg.Crop,
		arg.AreaInMeters,
		arg.StartSeason,
	)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.FieldID,
		&i.Name,
		&i.StartSeason,
		&i.FinishSeason,
		&i.Crop,
		&i.Boundary,
		&i.AreaInMeters,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRemainingAreaOfFieldForSeason = `-- name: GetRemainingAreaOfFieldForSeason :one
SELECT
    f.area_in_meters - COALESCE(SUM(s.area_in_meters), 0) AS field_remaining_area
FROM fields f
LEFT JOIN seasons s
    ON s.field_id = f.id
    AND s.deleted_at IS NULL
    AND s.finish_season IS NULL
WHERE f.deleted_at IS NULL AND f.id = $1
GROUP BY f.area_in_meters
`

func (q *Queries) GetRemainingAreaOfFieldForSeason(ctx context.Context, id int64) (float64, error) {
	row := q.db.QueryRow(ctx, getRemainingAreaOfFieldForSeason, id)
	var field_remaining_area float64
	err := row.Scan(&field_remaining_area)
	return field_remaining_area, err
}

const getSeasonById = `-- name: GetSeasonById :one
SELECT 
s.id,s.field_id,s.name,s.start_season,s.finish_season,s.crop,s.boundary,
  s.area_in_meters,s.created_at,s.updated_at,s.deleted_at,f.name as field_name,f.area_in_meters as field_area_in_meters,
  supplies.name as crop_name
FROM seasons s
JOIN supplies
ON supplies.id = crop
JOIN fields f
ON f.id = s.field_id
WHERE s.deleted_at IS NULL AND supplies.deleted_at IS NULL
AND s.field_id = $1 AND s.id = $2
`

type GetSeasonByIdParams struct {
	FieldID int64
	ID      int64
}

type GetSeasonByIdRow struct {
	ID                int64
	FieldID           int64
	Name              *string
	StartSeason       time.Time
	FinishSeason      pgtype.Timestamptz
	Crop              int64
	Boundary          *json.RawMessage
	AreaInMeters      float64
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	DeletedAt         pgtype.Timestamptz
	FieldName         string
	FieldAreaInMeters float64
	CropName          string
}

func (q *Queries) GetSeasonById(ctx context.Context, arg GetSeasonByIdParams) (GetSeasonByIdRow, error) {
	row := q.db.QueryRow(ctx, getSeasonById, arg.FieldID, arg.ID)
	var i GetSeasonByIdRow
	err := row.Scan(
		&i.ID,
		&i.FieldID,
		&i.Name,
		&i.StartSeason,
		&i.FinishSeason,
		&i.Crop,
		&i.Boundary,
		&i.AreaInMeters,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.FieldName,
		&i.FieldAreaInMeters,
		&i.CropName,
	)
	return i, err
}

const getSeasonsByFieldId = `-- name: GetSeasonsByFieldId :many
SELECT 
s.id,s.field_id,s.name,s.start_season,s.finish_season,s.crop,s.boundary,
  s.area_in_meters,s.created_at,s.updated_at,s.deleted_at,f.name as field_name,f.area_in_meters as field_area_in_meters,
  supplies.name as crop_name
FROM seasons s
JOIN supplies
ON supplies.id = crop
JOIN fields f
ON f.id = s.field_id
WHERE s.deleted_at IS NULL AND supplies.deleted_at IS NULL
AND s.field_id = $1
ORDER BY finish_season IS NULL DESC, updated_at DESC
`

type GetSeasonsByFieldIdRow struct {
	ID                int64
	FieldID           int64
	Name              *string
	StartSeason       time.Time
	FinishSeason      pgtype.Timestamptz
	Crop              int64
	Boundary          *json.RawMessage
	AreaInMeters      float64
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	DeletedAt         pgtype.Timestamptz
	FieldName         string
	FieldAreaInMeters float64
	CropName          string
}

func (q *Queries) GetSeasonsByFieldId(ctx context.Context, fieldID int64) ([]GetSeasonsByFieldIdRow, error) {
	rows, err := q.db.Query(ctx, getSeasonsByFieldId, fieldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonsByFieldIdRow
	for rows.Next() {
		var i GetSeasonsByFieldIdRow
		if err := rows.Scan(
			&i.ID,
			&i.FieldID,
			&i.Name,
			&i.StartSeason,
			&i.FinishSeason,
			&i.Crop,
			&i.Boundary,
			&i.AreaInMeters,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FieldName,
			&i.FieldAreaInMeters,
			&i.CropName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
