// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job_supplies.sql

package db

import (
	"context"
)

const getSeasonStatistics = `-- name: GetSeasonStatistics :many
SELECT SUM(js.quantity) as total_quantity,SUM(
  CASE
    WHEN j.job_type = 'harvesting' THEN js.quantity
    ELSE 0
  END
  ) as harvest_quantity,js.supply_id as supply_id, s.name as supply_name, s.measurement_unit
FROM jobs_supplies js
LEFT JOIN supplies s
ON s.id = js.supply_id
LEFT JOIN jobs j
ON j.id = js.job_id
LEFT JOIN seasons 
ON j.season_id = seasons.id
WHERE seasons.id = $1
GROUP BY js.supply_id,s.name,s.measurement_unit
`

type GetSeasonStatisticsRow struct {
	TotalQuantity   float64
	HarvestQuantity float64
	SupplyID        *int64
	SupplyName      *string
	MeasurementUnit *string
}

func (q *Queries) GetSeasonStatistics(ctx context.Context, id int64) ([]GetSeasonStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getSeasonStatistics, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonStatisticsRow
	for rows.Next() {
		var i GetSeasonStatisticsRow
		if err := rows.Scan(
			&i.TotalQuantity,
			&i.HarvestQuantity,
			&i.SupplyID,
			&i.SupplyName,
			&i.MeasurementUnit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
